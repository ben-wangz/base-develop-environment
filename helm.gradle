String chartVersion = project.ext.mainVersion
String runtimeHelmPackageDirectory = "${project.buildDir}/runtime/package/base-develop-envrionment"
String helmBinaryPath = "${project.buildDir}/runtime/bin/helm"
def helmPackageFile = project.file("${project.buildDir}/runtime/package/${project.getName()}-${project.getVersion()}.tgz")
task renderChartYaml() {
    def templateFile = project.file("template/Chart.template.yaml")
    def targetFile = project.file("helm/Chart.yaml")
    doLast {
        targetFile.text = project.ext.simpleTemplateEngine
                .createTemplate(templateFile.text)
                .make([
                        "doNotModifyComment": "DO NOT modify, auto-generated by Chart.template.yaml",
                        "softwareName"      : project.getName(),
                        "chartVersion"      : chartVersion,
                        "version"           : project.getVersion(),
                ])
    }
}
task downloadHelm() {
    if (project.file(helmBinaryPath).exists()) {
        println("skip ${name} as files exists")
        enabled(false)
    }
    doLast {
        String helmForCompilePackagePath = "${project.buildDir}/runtime/download/helm.tar.gz"
        downloadResource(constructHelmDownloadAddress(), project.file(helmForCompilePackagePath))
        def helmForCompilePackageDirectory = project.file(helmForCompilePackagePath).parentFile.getAbsolutePath()
        String extractDirectoryPath = "${helmForCompilePackageDirectory}/helm_for_compile"
        project.file(extractDirectoryPath).mkdirs()
        exec {
            def execSpec = commandLine(
                    "tar",
                    "zxvf",
                    helmForCompilePackagePath,
                    "-C",
                    extractDirectoryPath,
            )
            println("running command: ${String.join(" ", execSpec.getCommandLine())}")
        }
        copy {
            from "${extractDirectoryPath}/${constructHelmPackageDirectoryName()}/helm"
            into project.file(helmBinaryPath).parentFile.getAbsolutePath()
        }
    }
}
task helmPackage() {
    doFirst {
        project.file(runtimeHelmPackageDirectory).deleteDir()
        copy {
            from project.file("helm")
            into runtimeHelmPackageDirectory
        }
    }
    doLast {
        exec {
            def execSpec = commandLine(
                    helmBinaryPath, "dependency", "build", runtimeHelmPackageDirectory
            )
            println("running command: ${String.join(" ", execSpec.getCommandLine())}")
        }
        helmPackageFile.delete()
        exec {
            def execSpec = commandLine(
                    helmBinaryPath,
                    "package", runtimeHelmPackageDirectory,
                    "-d", helmPackageFile.parentFile.getAbsolutePath()
            )
            println("running command: ${String.join(" ", execSpec.getCommandLine())}")
        }
        if (!helmPackageFile.exists()) {
            throw new RuntimeException("helmPackageFile(${helmPackageFile}) not exists")
        }
    }
    dependsOn(downloadHelm)
    dependsOn(renderChartYaml)
}
def localValuesYaml = project.file("values/local.values.yaml")
task renderLocalValues() {
    def templateFile = project.file("template/local.values.template.yaml")
    def targetFile = localValuesYaml
    localValuesYaml.parentFile.mkdirs()
    doLast {
        def homePublicKey = project.file("${System.getenv("HOME")}/.ssh/id_rsa.pub")
        targetFile.text = project.ext.simpleTemplateEngine
                .createTemplate(templateFile.text)
                .make([
                        "doNotModifyComment": "DO NOT modify, auto-generated by Chart.template.yaml",
                        "IMAGE_REPOSITORY"  : project.ext.imageRepository,
                        "IMAGE_TAG"         : project.ext.imageTag,
                        "HOME_PUBLIC_KEY"   : homePublicKey.text,
                ])
    }
}
task helmInstall() {
    doLast {
        exec {
            def execSpec = commandLine(
                    helmBinaryPath,
                    "install",
                    "--create-namespace",
                    "--namespace", "developing",
                    "${project.getName()}-instance",
                    helmPackageFile,
                    "--values", localValuesYaml,
                    "--atomic",
            )
            println("running command: ${String.join(" ", execSpec.getCommandLine())}")
        }
    }
    dependsOn(renderLocalValues)
    dependsOn(helmPackage)
}
task helmUninstall() {
    doLast {
        exec {
            def execSpec = commandLine(
                    helmBinaryPath,
                    "uninstall",
                    "--namespace", "developing",
                    "${project.getName()}-instance",
            )
            println("running command: ${String.join(" ", execSpec.getCommandLine())}")
        }
    }
}

private static String constructHelmDownloadAddress() {
    def operatingSystem = org.gradle.internal.os.OperatingSystem.current();
    def arch = System.getProperty("os.arch")
    if (operatingSystem.isMacOsX() && "x86_64" == arch) {
        // mirror of https://get.helm.sh/helm-v3.6.2-darwin-amd64.tar.gz
        return "https://nginx.geekcity.tech/proxy/binary/helm/helm-v3.6.2-darwin-amd64.tar.gz"
    }
    if (operatingSystem.isLinux() && "amd64" == arch) {
        // mirror of https://get.helm.sh/helm-v3.6.2-linux-amd64.tar.gz
        return "https://nginx.geekcity.tech/proxy/binary/helm/helm-v3.6.2-linux-amd64.tar.gz"
    }
    // not fully tested
    if (operatingSystem.isMacOsX() && "aarch64" == arch) {
        // mirror of https://get.helm.sh/helm-v3.6.2-darwin-amd64.tar.gz
        return "https://nginx.geekcity.tech/proxy/binary/helm/helm-v3.6.2-darwin-arm64.tar.gz"
    }
    throw new RuntimeException("not supported operating system(${operatingSystem.getName()}) or arch(${arch})")
}

private static String constructHelmPackageDirectoryName() {
    def operatingSystem = org.gradle.internal.os.OperatingSystem.current();
    def arch = System.getProperty("os.arch")
    if (operatingSystem.isMacOsX() && "x86_64" == arch) {
        return "darwin-amd64"
    }
    if (operatingSystem.isLinux() && "amd64" == arch) {
        return "linux-amd64"
    }
    // not fully tested
    if (operatingSystem.isMacOsX() && "aarch64" == arch) {
        return "darwin-amd64"
    }
    throw new RuntimeException("not supported operating system(${operatingSystem.getName()}) or arch(${arch})")
}
